import { readFile } from "node:fs/promises";
import path from "node:path";
import pc from "picocolors";
import {
  Project,
  SourceFile,
  Symbol,
  SyntaxKind,
  ts,
  TypeFlags,
} from "ts-morph";

const JS_RESOURCE_FILENAME = "__generated__/river/js_resource.ts";
const JS_RESOURCE_TEMPLATE = "scripts/templates/js_resource.ts";
const ROUTER_FILENAME = "__generated__/river/router.tsx";
const ROUTER_TEMPLATE = "scripts/templates/router.tsx";
const SERVER_ROUTER_FILENAME = "__generated__/river/server_router.ts";
const SERVER_ROUTER_TEMPLATE = "scripts/templates/server_router.ts";

async function loadRiverFiles(project: Project) {
  async function loadSourceFile(fileName: string, templateFileName: string) {
    const template = await readFile(templateFileName, "utf-8");
    const warningComment = `/*
 * This file was generated by \`npm run generate:river\`.
 * Do not modify this file directly. Instead, edit the template at ${templateFileName}.
 */

`;
    return project.createSourceFile(fileName, warningComment + template, {
      overwrite: true,
    });
  }

  const [jsResource, router, serverRouter] = await Promise.all([
    loadSourceFile(JS_RESOURCE_FILENAME, JS_RESOURCE_TEMPLATE),
    loadSourceFile(ROUTER_FILENAME, ROUTER_TEMPLATE),
    loadSourceFile(SERVER_ROUTER_FILENAME, SERVER_ROUTER_TEMPLATE),
  ]);

  return { jsResource, router, serverRouter } as const;
}

type RiverResource = {
  resourceName: string;
  sourceFile: SourceFile;
  symbol: Symbol;
};

type RiverRoute = {
  routeName: string;
  sourceFile: SourceFile;
  symbol: Symbol;
  params: Map<string, ts.Type>;
};

function collectRiverNodes(project: Project) {
  const resources: RiverResource[] = [];
  const routes: RiverRoute[] = [];

  function visitRiverNodes(sourceFile: SourceFile) {
    sourceFile.getExportSymbols().forEach((symbol) => {
      let riverResource = null as RiverResource | null;
      let riverRoute = null as RiverRoute | null;
      const routeParams = new Map<string, ts.Type>();

      function visitJSDocTags(tag: ts.JSDoc | ts.JSDocTag) {
        if (ts.isJSDoc(tag)) {
          tag.tags?.forEach(visitJSDocTags);
        } else if (ts.isJSDocParameterTag(tag)) {
          const typeNode = tag.typeExpression?.type;
          const tc = project.getTypeChecker().compilerObject;

          const type =
            typeNode == null
              ? tc.getUnknownType()
              : tc.getTypeFromTypeNode(typeNode);

          routeParams.set(tag.name.getText(), type);
        } else if (typeof tag.comment === "string") {
          switch (tag.tagName.getText()) {
            case "route": {
              riverRoute = {
                routeName: tag.comment,
                sourceFile,
                symbol,
                params: routeParams,
              };
              break;
            }
            case "resource": {
              riverResource = {
                resourceName: tag.comment,
                sourceFile,
                symbol,
              };
              break;
            }
          }
        }
      }

      symbol
        .getDeclarations()
        .flatMap((decl) => ts.getJSDocCommentsAndTags(decl.compilerNode))
        .forEach(visitJSDocTags);

      if (riverRoute != null) routes.push(riverRoute);
      if (riverResource != null) resources.push(riverResource);
    });
  }

  project.getSourceFiles().forEach(visitRiverNodes);
  return { resources, routes } as const;
}

function zodSchemaOfType(tc: ts.TypeChecker, t: ts.Type): string {
  if (t.getFlags() & TypeFlags.String) {
    return `z.pipe(z.string(), z.transform(decodeURIComponent))`;
  } else if (t.getFlags() & TypeFlags.Number) {
    return `z.coerce.number<number>()`;
  } else if (t.getFlags() & TypeFlags.Null) {
    return `z.preprocess(s => s == null ? undefined : s, z.undefined())`;
  } else if (t.isUnion()) {
    const isRepresentingOptional =
      t.types.length === 2 &&
      t.types.some((s) => s.getFlags() & TypeFlags.Null);

    if (isRepresentingOptional) {
      const nonOptionalType = t.types.find(
        (s) => !(s.getFlags() & TypeFlags.Null),
      )!;

      return `z.pipe(z.nullish(${zodSchemaOfType(tc, nonOptionalType)}), z.transform(s => s == null ? undefined : s))`;
    } else {
      return `z.union([${t.types.map((it) => zodSchemaOfType(tc, it)).join(", ")}])`;
    }
  } else if (tc.isArrayLikeType(t)) {
    const typeArg = tc.getTypeArguments(t as ts.TypeReference)[0];
    const argZodSchema =
      typeArg == null ? `z.any()` : zodSchemaOfType(tc, typeArg);

    return `z.array(${argZodSchema})`;
  } else {
    console.log("Could not handle type:", tc.typeToString(t));
    return `z.any()`;
  }
}

async function main() {
  const project = new Project({ tsConfigFilePath: "tsconfig.json" });
  const tc = project.getTypeChecker().compilerObject;

  const riverFiles = await loadRiverFiles(project);
  const riverNodes = collectRiverNodes(project);

  const resourceConf = riverFiles.jsResource
    .getVariableDeclarationOrThrow("RESOURCE_CONF")
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  resourceConf.getPropertyOrThrow("noop").remove();
  for (const { resourceName, sourceFile, symbol } of riverNodes.resources) {
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    const moduleSpecifier =
      riverFiles.jsResource.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

    resourceConf.addPropertyAssignment({
      name: `"${resourceName}"`,
      initializer: (writer) => {
        writer.block(() => {
          writer
            .writeLine(`src: "${filePath}",`)
            .writeLine(
              `loader: () => import("${moduleSpecifier}").then(m => m.${symbol.getName()})`,
            );
        });
      },
    });

    console.log(
      "Created resource",
      pc.cyan(resourceName),
      "for",
      pc.green(symbol.getName()),
      "exported from",
      pc.yellow(filePath),
    );
  }

  const routerConf = riverFiles.router
    .getVariableDeclarationOrThrow("ROUTER_CONF")
    .getInitializerIfKindOrThrow(SyntaxKind.AsExpression)
    .getExpressionIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);

  routerConf.getPropertyOrThrow("noop").remove();

  let entryPointImportIndex = 0;
  for (const { routeName, sourceFile, symbol, params } of riverNodes.routes) {
    const importAlias = `e${entryPointImportIndex++}`;
    const filePath = path.relative(process.cwd(), sourceFile.getFilePath());
    const moduleSpecifier =
      riverFiles.router.getRelativePathAsModuleSpecifierTo(
        sourceFile.getFilePath(),
      );

    riverFiles.router.addImportDeclaration({
      moduleSpecifier,
      namedImports: [
        {
          name: symbol.getName(),
          alias: importAlias,
        },
      ],
    });

    routerConf.addPropertyAssignment({
      name: `"${routeName}"`,
      initializer: (writer) => {
        writer
          .write("{")
          .indent(() => {
            writer.writeLine(`entrypoint: ${importAlias},`);
            if (params.size === 0) {
              writer.writeLine(`schema: z.object({})`);
            } else {
              writer.writeLine(`schema: z.object({`);
              for (const [paramName, paramType] of params) {
                writer.writeLine(
                  `  ${paramName}: ${zodSchemaOfType(tc, paramType)},`,
                );
              }

              writer.writeLine("})");
            }
          })
          .write("} as const");
      },
    });

    console.log(
      "Created route",
      pc.cyan(routeName),
      "for",
      pc.green(symbol.getName()),
      "exported from",
      pc.yellow(filePath),
    );
  }

  await Promise.all([
    riverFiles.jsResource.save(),
    riverFiles.router.save(),
    riverFiles.serverRouter.save(),
  ]);
}

main().catch(console.error);
