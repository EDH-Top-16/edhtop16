/*
 * This file was generated by `pastoria`.
 * @generated-checksum e363cd847c64221edc0229cbedafeb813372e889fec40b5623877f917b4932a2
 * Do not modify this file directly. Instead, edit the template at router.tsx.
 */

import {
  AnyPreloadedEntryPoint,
  EnvironmentProvider,
  relayClientEnvironment,
  RouterOps,
} from 'pastoria-runtime';
import { createRouter } from 'radix3';
import {
  AnchorHTMLAttributes,
  createContext,
  PropsWithChildren,
  StrictMode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from 'react';
import { preinit, preloadModule } from 'react-dom';
import {
  EntryPoint,
  EntryPointContainer,
  EntryPointProps,
  loadEntryPoint,
  RelayEnvironmentProvider,
  useEntryPointLoader,
} from 'react-relay/hooks';
import * as z from 'zod/v4-mini';
import { JSResource, ModuleType } from './js_resource';
import { entrypoint as e0 } from '../../src/commander_page.entrypoint';
import { entrypoint as e1 } from '../../src/tournament_view.entrypoint';
import {
  schema as _EP_schema,
  entrypoint as _EP_entrypoint,
  Queries as _EP_Queries,
  EntryPoints as _EP_EntryPoints,
} from './page.entrypoint';
import {
  schema as about_EP_schema,
  entrypoint as about_EP_entrypoint,
  Queries as about_EP_Queries,
  EntryPoints as about_EP_EntryPoints,
} from './about_page.entrypoint';
import {
  schema as staples_EP_schema,
  entrypoint as staples_EP_entrypoint,
  Queries as staples_EP_Queries,
  EntryPoints as staples_EP_EntryPoints,
} from './staples_page.entrypoint';
import {
  schema as tournaments_EP_schema,
  entrypoint as tournaments_EP_entrypoint,
  Queries as tournaments_EP_Queries,
  EntryPoints as tournaments_EP_EntryPoints,
} from './tournaments_page.entrypoint';

/** Mapping of route name to Zod schema for parsing URL params. */
const ROUTER_SCHEMA = {
  '/commander/:commander': z.object({
    commander: z.pipe(z.string(), z.transform(decodeURIComponent)),
    tab: z.pipe(
      z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))),
      z.transform((s) => (s == null ? undefined : s)),
    ),
    card: z.pipe(
      z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))),
      z.transform((s) => (s == null ? undefined : s)),
    ),
    sortBy: z.pipe(
      z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))),
      z.transform((s) => (s == null ? undefined : s)),
    ),
    timePeriod: z.pipe(
      z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))),
      z.transform((s) => (s == null ? undefined : s)),
    ),
    maxStanding: z.pipe(
      z.nullish(z.coerce.number<number>()),
      z.transform((s) => (s == null ? undefined : s)),
    ),
    minEventSize: z.pipe(
      z.nullish(z.coerce.number<number>()),
      z.transform((s) => (s == null ? undefined : s)),
    ),
  }),
  '/tournament/:tid': z.object({
    tid: z.pipe(z.string(), z.transform(decodeURIComponent)),
    commander: z.pipe(
      z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))),
      z.transform((s) => (s == null ? undefined : s)),
    ),
    tab: z.pipe(
      z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))),
      z.transform((s) => (s == null ? undefined : s)),
    ),
  }),
};

/** Type of URL params for a route's EntryPoint type. */
export type EntryPointParams<R extends keyof typeof ROUTER_SCHEMA> = z.output<
  (typeof ROUTER_SCHEMA)[R]
>;

type RouterConf = typeof ROUTER_CONF;
const ROUTER_CONF = {
  '/commander/:commander': {
    entrypoint: e0,
    schema: ROUTER_SCHEMA['/commander/:commander'],
  } as const,
  '/tournament/:tid': {
    entrypoint: e1,
    schema: ROUTER_SCHEMA['/tournament/:tid'],
  } as const,
  '/': {
    entrypoint: _EP_entrypoint,
    schema: _EP_schema,
  } as const,
  '/about': {
    entrypoint: about_EP_entrypoint,
    schema: about_EP_schema,
  } as const,
  '/staples': {
    entrypoint: staples_EP_entrypoint,
    schema: staples_EP_schema,
  } as const,
  '/tournaments': {
    entrypoint: tournaments_EP_entrypoint,
    schema: tournaments_EP_schema,
  } as const,
} as const;

export type RouteId = keyof RouterConf;
export type NavigationDirection = string | URL | ((nextUrl: URL) => void);

const ROUTE_MAPPING = {
  '/commander/:commander': ROUTER_CONF['/commander/:commander'],
  '/tournament/:tid': ROUTER_CONF['/tournament/:tid'],
  '/': ROUTER_CONF['/'],
  '/about': ROUTER_CONF['/about'],
  '/staples': ROUTER_CONF['/staples'],
  '/tournaments': ROUTER_CONF['/tournaments'],
};

const ROUTER = createRouter<RouterConf[keyof RouterConf]>({
  routes: ROUTE_MAPPING,
});

class RouterLocation {
  private constructor(
    readonly pathname: string,
    readonly searchParams: URLSearchParams,
    readonly method?: 'push' | 'replace' | 'popstate',
  ) {}

  href() {
    if (this.searchParams.size > 0) {
      return this.pathname + '?' + this.searchParams.toString();
    }

    return this.pathname;
  }

  route() {
    return ROUTER.lookup(this.pathname);
  }

  params() {
    const matchedRoute = this.route();
    const params = {
      ...matchedRoute?.params,
      ...Object.fromEntries(this.searchParams),
    };

    if (matchedRoute?.schema) {
      return matchedRoute.schema.parse(params);
    } else {
      throw new Error(`Could not parse params for route: ${this.pathname}`);
    }
  }

  static parse(path: string, method?: 'push' | 'replace' | 'popstate') {
    if (path.startsWith('/')) {
      path = 'router:' + path;
    }

    try {
      const nextUrl = new URL(path);
      return new RouterLocation(nextUrl.pathname, nextUrl.searchParams, method);
    } catch (_e) {
      return new RouterLocation(path, new URLSearchParams(), method);
    }
  }
}

function useLocation(initialPath?: string) {
  const [location, setLocation] = useState((): RouterLocation => {
    return RouterLocation.parse(initialPath ?? window.location.href);
  });

  useEffect(() => {
    function listener(e: PopStateEvent) {
      setLocation(RouterLocation.parse(window.location.href, 'popstate'));
    }

    window.addEventListener('popstate', listener);
    return () => {
      window.removeEventListener('popstate', listener);
    };
  }, []);

  useEffect(() => {
    if (location.method === 'push') {
      window.history.pushState({}, '', location.href());
      window.scrollTo(0, 0);
    } else if (location.method === 'replace') {
      window.history.replaceState({}, '', location.href());
    }
  }, [location]);

  return [location, setLocation] as const;
}

export function router__hydrateStore(provider: EnvironmentProvider) {
  const env = provider.getEnvironment(null);
  if ('__router_ops' in window) {
    const ops = (window as any).__router_ops as RouterOps;
    for (const [op, payload] of ops) {
      env.commitPayload(op, payload);
    }
  }
}

export async function router__loadEntryPoint(
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  if (!initialPath) initialPath = window.location.href;
  const initialLocation = RouterLocation.parse(initialPath);
  const initialRoute = initialLocation.route();
  if (!initialRoute) return null;

  await initialRoute.entrypoint?.root.load();
  return loadEntryPoint(
    provider,
    initialRoute.entrypoint,
    initialLocation.params(),
  );
}

interface RouterContextValue {
  location: RouterLocation;
  setLocation: React.Dispatch<React.SetStateAction<RouterLocation>>;
}

const RouterContext = createContext<RouterContextValue>({
  location: RouterLocation.parse('/'),
  setLocation: () => {},
});

const REACT_REFRESH_SCRIPT = `
import RefreshRuntime from 'http://localhost:3000/@react-refresh'
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () => {}
window.$RefreshSig$ = () => (type) => type
window.__vite_plugin_react_preamble_installed__ = true`;

export function router__createAppFromEntryPoint(
  initialEntryPoint: AnyPreloadedEntryPoint | null,
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  const env = provider.getEnvironment(null);

  function RouterShell({
    preloadModules,
    preloadStylesheets,
    children,
  }: PropsWithChildren<{
    preloadModules?: string[];
    preloadStylesheets?: string[];
  }>) {
    for (const m of preloadModules ?? []) {
      preloadModule(m, { as: 'script' });
    }

    for (const s of preloadStylesheets ?? []) {
      preinit(s, { as: 'style' });
    }

    return (
      <StrictMode>
        <RelayEnvironmentProvider environment={env}>
          <html>
            <head>
              <meta charSet="utf-8" />
              <meta
                name="viewport"
                content="width=device-width, initial-scale=1"
              />

              {process.env.NODE_ENV !== 'production' && (
                <script
                  type="module"
                  dangerouslySetInnerHTML={{ __html: REACT_REFRESH_SCRIPT }}
                />
              )}
            </head>

            <body>{children}</body>
          </html>
        </RelayEnvironmentProvider>
      </StrictMode>
    );
  }

  function RouterCore() {
    const [location, setLocation] = useLocation(initialPath);
    const routerContextValue = useMemo(
      (): RouterContextValue => ({
        location,
        setLocation,
      }),
      [location, setLocation],
    );

    const [entryPointRef, loadEntryPointRef, _dispose] = useEntryPointLoader(
      provider,
      location.route()?.entrypoint,
    );

    useEffect(() => {
      loadEntryPointRef(location.params());
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [location]);

    const entryPoint = entryPointRef ?? initialEntryPoint;
    if (entryPoint == null) return null;

    return (
      <RouterContext value={routerContextValue}>
        <EntryPointContainer entryPointReference={entryPoint} props={{}} />
      </RouterContext>
    );
  }

  function RouterApp(props: {
    preloadModules?: string[];
    preloadStylesheets?: string[];
    App?: React.ComponentType<PropsWithChildren<{}>> | null;
  }) {
    return (
      <RouterShell
        preloadModules={props.preloadModules}
        preloadStylesheets={props.preloadStylesheets}
      >
        {props.App == null ? (
          <RouterCore />
        ) : (
          <props.App children={<RouterCore />} />
        )}
      </RouterShell>
    );
  }

  return RouterApp;
}

export async function createRouterApp() {
  const provider = relayClientEnvironment;

  router__hydrateStore(provider);
  const ep = await router__loadEntryPoint(provider);
  return router__createAppFromEntryPoint(ep, provider);
}

export function usePath() {
  const { location } = useContext(RouterContext);
  return location.pathname;
}

export function useRouteParams<R extends RouteId>(
  routeId: R,
): z.infer<RouterConf[R]['schema']> {
  const schema = ROUTER_CONF[routeId].schema;
  const { location } = useContext(RouterContext);

  return schema.parse(location.params()) as z.infer<RouterConf[R]['schema']>;
}

function router__createPathForRoute(
  routeId: RouteId,
  inputParams: Record<string, any>,
): string {
  const schema = ROUTER_CONF[routeId].schema;
  const params = schema.parse(inputParams);

  let pathname = routeId as string;
  const searchParams = new URLSearchParams();

  Object.entries(params).forEach(([key, value]) => {
    if (value != null) {
      const paramPattern = `:${key}`;
      if (pathname.includes(paramPattern)) {
        pathname = pathname.replace(
          paramPattern,
          encodeURIComponent(String(value)),
        );
      } else {
        searchParams.set(key, String(value));
      }
    }
  });

  if (searchParams.size > 0) {
    return pathname + '?' + searchParams.toString();
  } else {
    return pathname;
  }
}

function router__evaluateNavigationDirection(nav: NavigationDirection) {
  let nextUrl: URL;
  if (typeof nav === 'string') {
    nextUrl = new URL(nav, window.location.origin);
  } else if (nav instanceof URL) {
    nextUrl = nav;
  } else {
    nextUrl = new URL(window.location.href);
    nav(nextUrl);
  }

  if (window.location.origin !== nextUrl.origin) {
    throw new Error('Cannot navigate to a different origin.');
  }

  if (nextUrl.searchParams.size > 0) {
    return nextUrl.pathname + '?' + nextUrl.searchParams.toString();
  } else {
    return nextUrl.pathname;
  }
}

export function useNavigation() {
  const { setLocation } = useContext(RouterContext);

  return useMemo(() => {
    function push(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(router__evaluateNavigationDirection(nav), 'push'),
      );
    }

    function replace(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(
          router__evaluateNavigationDirection(nav),
          'replace',
        ),
      );
    }

    function pushRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation(
        RouterLocation.parse(
          router__createPathForRoute(routeId, params),
          'push',
        ),
      );
    }

    function replaceRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation((prevLoc) =>
        RouterLocation.parse(
          router__createPathForRoute(routeId, {
            ...prevLoc.params(),
            ...params,
          }),
          'replace',
        ),
      );
    }

    return { push, replace, pushRoute, replaceRoute } as const;
  }, [setLocation]);
}

export function Link({
  href,
  target,
  onClick,
  ...props
}: AnchorHTMLAttributes<HTMLAnchorElement>) {
  const { push } = useNavigation();

  const handleClick = useCallback(
    (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
      onClick?.(e);
      if (e.defaultPrevented || !href) return;

      // See https://github.com/remix-run/react-router/blob/main/packages/react-router/lib/dom/dom.ts#L34
      const shouldHandle =
        e.button === 0 &&
        (!target || target === '_self') &&
        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);

      if (!shouldHandle) return;

      const destination = new URL(href, window.location.href);
      if (destination.origin !== window.location.origin) return;

      e.preventDefault();
      push(destination);
    },
    [push, href, target, onClick],
  );

  return <a {...props} href={href} target={target} onClick={handleClick} />;
}

export interface LinkProps<R extends RouteId>
  extends AnchorHTMLAttributes<HTMLAnchorElement> {
  route: R;
  params: z.input<RouterConf[R]['schema']>;
  href?: never;
}

export function RouteLink<R extends RouteId>({
  route,
  params,
  ...props
}: PropsWithChildren<LinkProps<R>>) {
  const href = useMemo(
    () => router__createPathForRoute(route, params).toString(),
    [params, route],
  );

  return <Link {...props} href={href} />;
}

export function listRoutes() {
  return Object.keys(ROUTE_MAPPING);
}

declare global {
  type PastoriaRouteName = '/' | '/about' | '/staples' | '/tournaments';

  type PastoriaPageQueries = {
    ['/']: _EP_Queries;
    ['/about']: about_EP_Queries;
    ['/staples']: staples_EP_Queries;
    ['/tournaments']: tournaments_EP_Queries;
  };

  type PastoriaPageEntryPoints = {
    ['/']: _EP_EntryPoints;
    ['/about']: about_EP_EntryPoints;
    ['/staples']: staples_EP_EntryPoints;
    ['/tournaments']: tournaments_EP_EntryPoints;
  };

  type PastoriaPageProps<T extends PastoriaRouteName> = EntryPointProps<
    PastoriaPageQueries[T],
    PastoriaPageEntryPoints[T],
    {},
    {}
  >;
}
