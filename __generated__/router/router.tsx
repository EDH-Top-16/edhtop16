/*
 * This file was generated by `pastoria`.
 * Do not modify this file directly.
 */

import {
  AnyPreloadedEntryPoint,
  EnvironmentProvider,
  relayClientEnvironment,
  RouterOps,
} from 'pastoria-runtime';
import {createRouter} from 'radix3';
import React, {
  AnchorHTMLAttributes,
  createContext,
  PropsWithChildren,
  StrictMode,
  Suspense,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from 'react';
import {preinit, preloadModule} from 'react-dom';
import {
  EntryPoint,
  EntryPointContainer,
  loadEntryPoint,
  RelayEnvironmentProvider,
  useEntryPointLoader,
} from 'react-relay/hooks';
import {PreloadableQueryRegistry} from 'relay-runtime';
import * as z from 'zod/v4-mini';
import { JSResource, ModuleType } from "./js_resource";
import type { QueryHelpersForRoute, EntryPointHelpersForRoute } from "./types";
import page_HomePagePromoQueryParameters from "#genfiles/queries/page_HomePagePromoQuery$parameters";
import type { page_HomePagePromoQuery$variables } from "#genfiles/queries/page_HomePagePromoQuery.graphql";
import commanders_CommandersQueryParameters from "#genfiles/queries/commanders_CommandersQuery$parameters";
import type { commanders_CommandersQuery$variables } from "#genfiles/queries/commanders_CommandersQuery.graphql";
import content_StaplesQueryParameters from "#genfiles/queries/content_StaplesQuery$parameters";
import type { content_StaplesQuery$variables } from "#genfiles/queries/content_StaplesQuery.graphql";
import tournaments_TournamentsQueryParameters from "#genfiles/queries/tournaments_TournamentsQuery$parameters";
import type { tournaments_TournamentsQuery$variables } from "#genfiles/queries/tournaments_TournamentsQuery.graphql";
import page_TournamentPageQueryParameters from "#genfiles/queries/page_TournamentPageQuery$parameters";
import type { page_TournamentPageQuery$variables } from "#genfiles/queries/page_TournamentPageQuery.graphql";

type RouterConf = typeof ROUTER_CONF;
type AnyRouteParams = z.infer<RouterConf[keyof RouterConf]['schema']>;
type AnyRouteEntryPoint = RouterConf[keyof RouterConf]['entrypoint'];
type LoadEntryPointFn = (params: {params: AnyRouteParams}) => void;

const ROUTER_CONF = {
  "/": {
      entrypoint: entrypoint_fs_page___(),
      schema: z.object({ colorId: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)), minEntries: z.pipe(z.nullish(z.coerce.number<number>()), z.transform(s => s == null ? undefined : s)), minSize: z.pipe(z.nullish(z.coerce.number<number>()), z.transform(s => s == null ? undefined : s)), sortBy: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/commanders_CommandersQuery.graphql').CommandersSortBy)), z.transform(s => s == null ? undefined : s)), timePeriod: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/commanders_CommandersQuery.graphql').TimePeriod)), z.transform(s => s == null ? undefined : s)) })
    } as const,
  "/about": {
      entrypoint: entrypoint_fs_page__about_(),
      schema: z.object({})
    } as const,
  "/staples": {
      entrypoint: entrypoint_fs_page__staples_(),
      schema: z.object({ colorId: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)), type: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)) })
    } as const,
  "/tournaments": {
      entrypoint: entrypoint_fs_page__tournaments_(),
      schema: z.object({ minSize: z.pipe(z.nullish(z.coerce.number<number>()), z.transform(s => s == null ? undefined : s)), sortBy: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/tournaments_TournamentsQuery.graphql').TournamentSortBy)), z.transform(s => s == null ? undefined : s)), timePeriod: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/tournaments_TournamentsQuery.graphql').TimePeriod)), z.transform(s => s == null ? undefined : s)) })
    } as const,
  "/tournament/[tid]": {
      entrypoint: entrypoint_fs_page__tournament__tid__(),
      schema: z.object({ tid: z.pipe(z.string(), z.transform(decodeURIComponent)), commander: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)) })
    } as const
} as const;

export type RouteId = keyof RouterConf;
export type NavigationDirection = string | URL | ((nextUrl: URL) => void);

export interface EntryPointParams<R extends RouteId> {
  params: z.infer<RouterConf[R]['schema']>;
  queries: QueryHelpersForRoute<R>;
  entryPoints: EntryPointHelpersForRoute<R>;
}

/**
 * Load a route entry point with proper typing.
 *
 * This wrapper exists because TypeScript struggles with union type inference
 * when calling loadEntryPoint with a union of entry point types. All route
 * entry points accept {params: Record<string, unknown>}, so this is safe.
 */
function loadRouteEntryPoint(
  provider: EnvironmentProvider,
  entrypoint: AnyRouteEntryPoint,
  params: {params: AnyRouteParams},
) {
  // Cast needed because Relay's loadEntryPoint infers params from the entry point type.
  // When entrypoint is a union, the inferred params become an intersection (contravariance),
  // which resolves to `never`. Our entry points all accept the same params shape, so this is safe.
  return loadEntryPoint(
    provider,
    entrypoint as unknown as EntryPoint<unknown, {params: AnyRouteParams}>,
    params,
  );
}

// Convert bracket format [param] to colon format :param for radix3 router
function bracketToColon(path: string): string {
  // Convert required params [param] to :param
  // Note: optional params [[param]] are handled separately by expandOptionalRoutes
  return path.replace(/\[([^\]]+)\]/g, ':$1');
}

// Expand routes with optional params into multiple routes
// e.g., /greet/[[name]] becomes ['/greet', '/greet/:name']
function expandOptionalRoutes(
  routePath: string,
  config: RouterConf[keyof RouterConf],
): Array<[string, RouterConf[keyof RouterConf]]> {
  // Check if route has optional params
  const optionalMatch = routePath.match(/\/\[\[([^\]]+)\]\]/g);
  if (!optionalMatch) {
    // No optional params, just convert brackets to colons
    return [[bracketToColon(routePath), config]];
  }

  // For routes with optional params, create two routes:
  // 1. Without the optional segment (e.g., /greet)
  // 2. With the optional segment as required (e.g., /greet/:name)
  const withoutOptional = routePath.replace(/\/\[\[([^\]]+)\]\]/g, '');
  const withOptional = routePath.replace(/\[\[([^\]]+)\]\]/g, '[$1]');

  const routes: Array<[string, RouterConf[keyof RouterConf]]> = [];

  // Add the route without optional param (handles /greet)
  const pathWithout = bracketToColon(withoutOptional) || '/';
  routes.push([pathWithout, config]);

  // Add the route with optional param as required (handles /greet/:name)
  routes.push([bracketToColon(withOptional), config]);

  return routes;
}

// Create radix3 router with colon-format paths (radix3 uses :param syntax)
// Routes with optional params are expanded into multiple routes
const ROUTER = createRouter<RouterConf[keyof RouterConf]>({
  routes: Object.fromEntries(
    Object.entries(ROUTER_CONF).flatMap(([k, v]) => expandOptionalRoutes(k, v)),
  ) as Record<string, RouterConf[keyof RouterConf]>,
});

class RouterLocation {
  private constructor(
    readonly pathname: string,
    readonly searchParams: URLSearchParams,
    readonly method?: 'push' | 'replace' | 'popstate',
  ) {}

  href() {
    if (this.searchParams.size > 0) {
      return this.pathname + '?' + this.searchParams.toString();
    }

    return this.pathname;
  }

  route() {
    return ROUTER.lookup(this.pathname);
  }

  params(): AnyRouteParams {
    const matchedRoute = this.route();
    const params = {
      ...matchedRoute?.params,
      ...Object.fromEntries(this.searchParams),
    };

    if (matchedRoute?.schema) {
      return matchedRoute.schema.parse(params);
    } else {
      return params as AnyRouteParams;
    }
  }

  static parse(path: string, method?: 'push' | 'replace' | 'popstate') {
    if (path.startsWith('/')) {
      path = 'router:' + path;
    }

    try {
      const nextUrl = new URL(path);
      return new RouterLocation(nextUrl.pathname, nextUrl.searchParams, method);
    } catch (_e) {
      return new RouterLocation(path, new URLSearchParams(), method);
    }
  }
}

function useLocation(initialPath?: string) {
  const [location, setLocation] = useState((): RouterLocation => {
    return RouterLocation.parse(initialPath ?? window.location.href);
  });

  useEffect(() => {
    function listener(e: PopStateEvent) {
      setLocation(RouterLocation.parse(window.location.href, 'popstate'));
    }

    window.addEventListener('popstate', listener);
    return () => {
      window.removeEventListener('popstate', listener);
    };
  }, []);

  useEffect(() => {
    if (location.method === 'push') {
      window.history.pushState({}, '', location.href());
      window.scrollTo(0, 0);
    } else if (location.method === 'replace') {
      window.history.replaceState({}, '', location.href());
    }
  }, [location]);

  return [location, setLocation] as const;
}

export function router__hydrateStore(provider: EnvironmentProvider) {
  const env = provider.getEnvironment(null);
  if ('__router_ops' in window) {
    const ops = (window as any).__router_ops as RouterOps;
    for (const [op, payload] of ops) {
      // Register the ConcreteRequest with PreloadableQueryRegistry so that
      // loadQuery can find it and check store availability instead of
      // immediately fetching. This is critical for nested entry points whose
      // query modules haven't been loaded yet.
      const concreteRequest = op.request?.node;
      const queryId = concreteRequest?.params?.id;
      if (queryId && concreteRequest) {
        PreloadableQueryRegistry.set(queryId, concreteRequest);
      }
      env.commitPayload(op, payload);
    }
  }
}

export async function router__loadEntryPoint(
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  if (!initialPath) initialPath = window.location.href;
  const initialLocation = RouterLocation.parse(initialPath);
  const initialRoute = initialLocation.route();
  if (!initialRoute) return null;

  await initialRoute.entrypoint?.root.load();
  const ep = loadRouteEntryPoint(provider, initialRoute.entrypoint, {
    params: initialLocation.params(),
  });

  // Recursively load all nested entry point modules.
  // This ensures their queries get registered in PreloadableQueryRegistry
  // before the server tries to serialize them.
  await loadNestedEntryPointModules(ep);

  return ep;
}

/**
 * Recursively load all nested entry point modules so their queries
 * get registered in PreloadableQueryRegistry.
 */
async function loadNestedEntryPointModules(
  entryPoint: AnyPreloadedEntryPoint | null,
): Promise<void> {
  if (!entryPoint) return;
  for (const nestedEntry of Object.values(entryPoint.entryPoints ?? {})) {
    if (nestedEntry.rootModuleID) {
      await JSResource.fromModuleId(nestedEntry.rootModuleID as any).load();
    }
    await loadNestedEntryPointModules(nestedEntry);
  }
}

interface RouterContextValue {
  location: RouterLocation;
  setLocation: React.Dispatch<React.SetStateAction<RouterLocation>>;
}

const RouterContext = createContext<RouterContextValue>({
  location: RouterLocation.parse('/'),
  setLocation: () => {},
});

const REACT_REFRESH_SCRIPT = `
import RefreshRuntime from 'http://localhost:3000/@react-refresh'
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () => {}
window.$RefreshSig$ = () => (type) => type
window.__vite_plugin_react_preamble_installed__ = true`;

export function router__createAppFromEntryPoint(
  initialEntryPoint: AnyPreloadedEntryPoint | null,
  provider: EnvironmentProvider,
  initialPath?: string,
) {
  const env = provider.getEnvironment(null);

  function RouterShell({
    preloadModules,
    preloadStylesheets,
    children,
  }: PropsWithChildren<{
    preloadModules?: string[];
    preloadStylesheets?: string[];
  }>) {
    for (const m of preloadModules ?? []) {
      preloadModule(m, {as: 'script'});
    }

    for (const s of preloadStylesheets ?? []) {
      preinit(s, {as: 'style'});
    }

    return (
      <StrictMode>
        <RelayEnvironmentProvider environment={env}>
          <html>
            <head>
              <meta charSet="utf-8" />
              <meta
                name="viewport"
                content="width=device-width, initial-scale=1"
              />

              {process.env.NODE_ENV !== 'production' && (
                <script
                  type="module"
                  dangerouslySetInnerHTML={{__html: REACT_REFRESH_SCRIPT}}
                />
              )}
            </head>

            <body>{children}</body>
          </html>
        </RelayEnvironmentProvider>
      </StrictMode>
    );
  }

  function RouterCore() {
    const [location, setLocation] = useLocation(initialPath);
    const routerContextValue = useMemo(
      (): RouterContextValue => ({
        location,
        setLocation,
      }),
      [location, setLocation],
    );

    const [entryPointRef, loadEntryPointRef, _dispose] = useEntryPointLoader(
      provider,
      location.route()?.entrypoint,
    );

    useEffect(() => {
      const route = location.route();
      if (route) {
        // Cast needed for same reason as loadRouteEntryPoint - see that function's docs
        (loadEntryPointRef as LoadEntryPointFn)({params: location.params()});
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [location]);

    const entryPoint = entryPointRef ?? initialEntryPoint;
    if (entryPoint == null) return null;

    return (
      <RouterContext value={routerContextValue}>
        <EntryPointContainer entryPointReference={entryPoint} props={{}} />
      </RouterContext>
    );
  }

  function RouterApp(props: {
    preloadModules?: string[];
    preloadStylesheets?: string[];
    App?: React.ComponentType<PropsWithChildren<{}>> | null;
  }) {
    return (
      <RouterShell
        preloadModules={props.preloadModules}
        preloadStylesheets={props.preloadStylesheets}
      >
        {props.App == null ? (
          <RouterCore />
        ) : (
          <props.App children={<RouterCore />} />
        )}
      </RouterShell>
    );
  }

  return RouterApp;
}

export async function createRouterApp() {
  const provider = relayClientEnvironment;

  router__hydrateStore(provider);
  const ep = await router__loadEntryPoint(provider);
  return router__createAppFromEntryPoint(ep, provider);
}

export function usePath() {
  const {location} = useContext(RouterContext);
  return location.pathname;
}

export function useRouteParams<R extends RouteId>(
  routeId: R,
): z.infer<RouterConf[R]['schema']> {
  const schema = ROUTER_CONF[routeId].schema;
  const {location} = useContext(RouterContext);

  return schema.parse(location.params()) as z.infer<RouterConf[R]['schema']>;
}

function router__createPathForRoute(
  routeId: RouteId,
  inputParams: Record<string, unknown>,
): string {
  const schema = ROUTER_CONF[routeId].schema;
  const params = schema.parse(inputParams);

  let pathname = routeId as string;
  const searchParams = new URLSearchParams();

  Object.entries(params).forEach(([key, value]) => {
    // Check for optional param pattern first: [[key]]
    const optionalPattern = `[[${key}]]`;
    if (pathname.includes(optionalPattern)) {
      if (value != null) {
        pathname = pathname.replace(
          optionalPattern,
          encodeURIComponent(String(value)),
        );
      } else {
        // Remove the optional segment entirely (including the preceding slash if present)
        pathname = pathname.replace(`/${optionalPattern}`, '');
        pathname = pathname.replace(optionalPattern, '');
      }
      return;
    }

    // Check for required param pattern: [key]
    const paramPattern = `[${key}]`;
    if (pathname.includes(paramPattern)) {
      if (value != null) {
        pathname = pathname.replace(
          paramPattern,
          encodeURIComponent(String(value)),
        );
      }
      return;
    }

    // Not a path param, add to search params if non-null
    if (value != null) {
      searchParams.set(key, String(value));
    }
  });

  // Clean up any double slashes that might result
  pathname = pathname.replace(/\/+/g, '/');
  // Ensure we don't end up with empty path
  if (pathname === '') {
    pathname = '/';
  }

  if (searchParams.size > 0) {
    return pathname + '?' + searchParams.toString();
  } else {
    return pathname;
  }
}

function router__evaluateNavigationDirection(nav: NavigationDirection) {
  let nextUrl: URL;
  if (typeof nav === 'string') {
    nextUrl = new URL(nav, window.location.origin);
  } else if (nav instanceof URL) {
    nextUrl = nav;
  } else {
    nextUrl = new URL(window.location.href);
    nav(nextUrl);
  }

  if (window.location.origin !== nextUrl.origin) {
    throw new Error('Cannot navigate to a different origin.');
  }

  if (nextUrl.searchParams.size > 0) {
    return nextUrl.pathname + '?' + nextUrl.searchParams.toString();
  } else {
    return nextUrl.pathname;
  }
}

export function useNavigation() {
  const {setLocation} = useContext(RouterContext);

  return useMemo(() => {
    function push(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(router__evaluateNavigationDirection(nav), 'push'),
      );
    }

    function replace(nav: NavigationDirection) {
      setLocation(
        RouterLocation.parse(
          router__evaluateNavigationDirection(nav),
          'replace',
        ),
      );
    }

    function pushRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation(
        RouterLocation.parse(
          router__createPathForRoute(routeId, params),
          'push',
        ),
      );
    }

    function replaceRoute<R extends RouteId>(
      routeId: R,
      params: z.input<RouterConf[R]['schema']>,
    ) {
      setLocation((prevLoc) =>
        RouterLocation.parse(
          router__createPathForRoute(routeId, {...prevLoc.params(), ...params}),
          'replace',
        ),
      );
    }

    return {push, replace, pushRoute, replaceRoute} as const;
  }, [setLocation]);
}

export function Link({
  href,
  target,
  onClick,
  ...props
}: AnchorHTMLAttributes<HTMLAnchorElement>) {
  const {push} = useNavigation();

  const handleClick = useCallback(
    (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
      onClick?.(e);
      if (e.defaultPrevented || !href) return;

      // See https://github.com/remix-run/react-router/blob/main/packages/react-router/lib/dom/dom.ts#L34
      const shouldHandle =
        e.button === 0 &&
        (!target || target === '_self') &&
        !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);

      if (!shouldHandle) return;

      const destination = new URL(href, window.location.href);
      if (destination.origin !== window.location.origin) return;

      e.preventDefault();
      push(destination);
    },
    [push, href, target, onClick],
  );

  return <a {...props} href={href} target={target} onClick={handleClick} />;
}

export interface LinkProps<R extends RouteId>
  extends AnchorHTMLAttributes<HTMLAnchorElement> {
  route: R;
  params: z.input<RouterConf[R]['schema']>;
  href?: never;
}

export function RouteLink<R extends RouteId>({
  route,
  params,
  ...props
}: PropsWithChildren<LinkProps<R>>) {
  const href = useMemo(
    () => router__createPathForRoute(route, params).toString(),
    [params, route],
  );

  return <Link {...props} href={href} />;
}

export function listRoutes() {
  return Object.keys(ROUTER_CONF);
}

function entrypoint_fs_page___() {
  const schema = z.object({ colorId: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)), minEntries: z.pipe(z.nullish(z.coerce.number<number>()), z.transform(s => s == null ? undefined : s)), minSize: z.pipe(z.nullish(z.coerce.number<number>()), z.transform(s => s == null ? undefined : s)), sortBy: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/commanders_CommandersQuery.graphql').CommandersSortBy)), z.transform(s => s == null ? undefined : s)), timePeriod: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/commanders_CommandersQuery.graphql').TimePeriod)), z.transform(s => s == null ? undefined : s)) });
  const queryHelpers = {
    promoQueryRef: (variables: page_HomePagePromoQuery$variables) => ({ parameters: page_HomePagePromoQueryParameters, variables }),
  }
  ;
  const entryPointHelpers = {
    commanders: (variables: commanders_CommandersQuery$variables) => ( {
      entryPointParams: {},
      entryPoint: {
        root: JSResource.fromModuleId('fs:page(/)#commanders'),
        getPreloadProps() {
          return {
            queries: {
              commandersQueryRef: { parameters: commanders_CommandersQueryParameters, variables },
            }
            ,
            entryPoints: undefined
          }
        }
      }
    }
    ),
  }
  ;
  function getPreloadProps({params, queries, entryPoints}: EntryPointParams<'/'>) {
    const variables = params;
    return {
      queries: {
        promoQueryRef: queries.promoQueryRef({}),
      }
      ,
      entryPoints: {
        commanders: entryPoints.commanders({colorId: variables.colorId, minEntries: variables.minEntries, minSize: variables.minSize, sortBy: variables.sortBy, timePeriod: variables.timePeriod}),
      }
    }
  }
  return {
    root: JSResource.fromModuleId('fs:page(/)'),
    getPreloadProps: (p: {params: Record<string, unknown>}) => getPreloadProps({
      params: p.params as z.infer<typeof schema>,
      queries: queryHelpers,
      entryPoints: entryPointHelpers,
    }),
  }
}

function entrypoint_fs_page__about_() {
  const schema = z.object({});
  const queryHelpers = {
  }
  ;
  const entryPointHelpers = {
  }
  ;
  function getPreloadProps({params, queries, entryPoints}: EntryPointParams<'/about'>) {
    const variables = params;
    return {
      queries: {
      }
      ,
      entryPoints: undefined
    }
  }
  return {
    root: JSResource.fromModuleId('fs:page(/about)'),
    getPreloadProps: (p: {params: Record<string, unknown>}) => getPreloadProps({
      params: p.params as z.infer<typeof schema>,
      queries: queryHelpers,
      entryPoints: entryPointHelpers,
    }),
  }
}

function entrypoint_fs_page__staples_() {
  const schema = z.object({ colorId: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)), type: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)) });
  const queryHelpers = {
  }
  ;
  const entryPointHelpers = {
    content: (variables: content_StaplesQuery$variables) => ( {
      entryPointParams: {},
      entryPoint: {
        root: JSResource.fromModuleId('fs:page(/staples)#content'),
        getPreloadProps() {
          return {
            queries: {
              staplesQueryRef: { parameters: content_StaplesQueryParameters, variables },
            }
            ,
            entryPoints: undefined
          }
        }
      }
    }
    ),
  }
  ;
  function getPreloadProps({params, queries, entryPoints}: EntryPointParams<'/staples'>) {
    const variables = params;
    return {
      queries: {
      }
      ,
      entryPoints: {
        content: entryPoints.content({colorId: variables.colorId, type: variables.type}),
      }
    }
  }
  return {
    root: JSResource.fromModuleId('fs:page(/staples)'),
    getPreloadProps: (p: {params: Record<string, unknown>}) => getPreloadProps({
      params: p.params as z.infer<typeof schema>,
      queries: queryHelpers,
      entryPoints: entryPointHelpers,
    }),
  }
}

function entrypoint_fs_page__tournaments_() {
  const schema = z.object({ minSize: z.pipe(z.nullish(z.coerce.number<number>()), z.transform(s => s == null ? undefined : s)), sortBy: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/tournaments_TournamentsQuery.graphql').TournamentSortBy)), z.transform(s => s == null ? undefined : s)), timePeriod: z.pipe(z.nullish(z.transform((s: string) => s as import('../queries/tournaments_TournamentsQuery.graphql').TimePeriod)), z.transform(s => s == null ? undefined : s)) });
  const queryHelpers = {
  }
  ;
  const entryPointHelpers = {
    tournaments: (variables: tournaments_TournamentsQuery$variables) => ( {
      entryPointParams: {},
      entryPoint: {
        root: JSResource.fromModuleId('fs:page(/tournaments)#tournaments'),
        getPreloadProps() {
          return {
            queries: {
              tournamentQueryRef: { parameters: tournaments_TournamentsQueryParameters, variables },
            }
            ,
            entryPoints: undefined
          }
        }
      }
    }
    ),
  }
  ;
  function getPreloadProps({params, queries, entryPoints}: EntryPointParams<'/tournaments'>) {
    const variables = params;
    return {
      queries: {
      }
      ,
      entryPoints: {
        tournaments: entryPoints.tournaments({minSize: variables.minSize, sortBy: variables.sortBy, timePeriod: variables.timePeriod}),
      }
    }
  }
  return {
    root: JSResource.fromModuleId('fs:page(/tournaments)'),
    getPreloadProps: (p: {params: Record<string, unknown>}) => getPreloadProps({
      params: p.params as z.infer<typeof schema>,
      queries: queryHelpers,
      entryPoints: entryPointHelpers,
    }),
  }
}

function entrypoint_fs_page__tournament__tid__() {
  const schema = z.object({ tid: z.pipe(z.string(), z.transform(decodeURIComponent)), commander: z.pipe(z.nullish(z.pipe(z.string(), z.transform(decodeURIComponent))), z.transform(s => s == null ? undefined : s)) });
  const queryHelpers = {
    tournamentQueryRef: (variables: page_TournamentPageQuery$variables) => ({ parameters: page_TournamentPageQueryParameters, variables }),
  }
  ;
  const entryPointHelpers = {
  }
  ;
  function getPreloadProps({params, queries, entryPoints}: EntryPointParams<'/tournament/[tid]'>) {
    const variables = params;
    return {
      queries: {
        tournamentQueryRef: queries.tournamentQueryRef({commander: variables.commander, tid: variables.tid}),
      }
      ,
      entryPoints: undefined
    }
  }
  return {
    root: JSResource.fromModuleId('fs:page(/tournament/[tid])'),
    getPreloadProps: (p: {params: Record<string, unknown>}) => getPreloadProps({
      params: p.params as z.infer<typeof schema>,
      queries: queryHelpers,
      entryPoints: entryPointHelpers,
    }),
  }
}
