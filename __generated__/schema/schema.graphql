# Schema generated by Grats (https://grats.capt.dev)
# Do not manually edit. Regenerate by running `npx grats`.
"""
Indicates that a position is semantically non null: it is only null if there is a matching error in the `errors` array.
In all other cases, the position is non-null.

Tools doing code generation may use this information to generate the position as non-null if field errors are handled out of band:

```graphql
type User {
    # email is semantically non-null and can be generated as non-null by error-handling clients.
    email: String @semanticNonNull
}
```

The `levels` argument indicates what levels are semantically non null in case of lists:

```graphql
type User {
    # friends is semantically non null
    friends: [User] @semanticNonNull # same as @semanticNonNull(levels: [0])

    # every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [1])

    # friends as well as every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [0, 1])
}
```

`levels` are zero indexed.
Passing a negative level or a level greater than the list dimension is an error.
"""
directive @semanticNonNull(levels: [Int] = [0]) on FIELD_DEFINITION

enum CommandersSortBy {
  CONVERSION
  POPULARITY
  TOP_CUTS
}

enum EntriesSortBy {
  NEW
  TOP
}

enum EntrySortBy {
  DATE
  DRAWS
  LOSSES
  STANDING
  WINRATE
  WINS
}

enum SearchResultType {
  COMMANDER
  TOURNAMENT
}

enum SortDirection {
  ASC
  DESC
}

enum TimePeriod {
  ALL_TIME
  ONE_MONTH
  ONE_YEAR
  POST_BAN
  SIX_MONTHS
  THREE_MONTHS
}

enum TournamentSortBy {
  DATE
  PLAYERS
}

interface Node {
  id: ID!
}

input CardEntriesFilters {
  colorId: String
  commanderName: String
  tournamentTID: String
}

input CommanderStatsFilters {
  colorId: String
  maxDate: String
  maxSize: Int
  minDate: String
  minSize: Int
  timePeriod: TimePeriod
}

input EntriesFilter {
  maxStanding: Int
  minEventSize: Int!
  timePeriod: TimePeriod!
}

input EntryFilters {
  maxDate: String
  maxDraws: Int
  maxLosses: Int
  maxSize: Int
  maxStanding: Int
  maxWins: Int
  minDate: String
  minDraws: Int
  minLosses: Int
  minSize: Int
  minStanding: Int
  minWins: Int
}

input TournamentFilters {
  maxDate: String
  maxSize: Int
  minDate: String
  minSize: Int
  timePeriod: TimePeriod
}

type Card implements Node {
  """Image of the full front card face."""
  cardPreviewImageUrl: String
  cmc: Int @semanticNonNull
  colorId: String @semanticNonNull
  entries(after: String, filters: CardEntriesFilters, first: Int! = 20): EntryConnection @semanticNonNull
  id: ID!
  """URL's of art crops for each card face."""
  imageUrls: [String!] @semanticNonNull
  """
  Mana cost string in Scryfall format, e.g. "{2}{W}{U}"
  """
  manaCost: String @semanticNonNull
  name: String @semanticNonNull
  oracleId: String @semanticNonNull
  playRateLastYear: Float @semanticNonNull
  """Link to the card on Scryfall."""
  scryfallUrl: String @semanticNonNull
  type: String @semanticNonNull
}

type Commander implements Node {
  breakdownUrl: String @semanticNonNull
  cardDetail(cardName: String): Card
  cardEntries(after: String, cardName: String, first: Int! = 20, sortBy: EntriesSortBy! = TOP): EntryConnection @semanticNonNull
  cardWinrateStats(cardName: String, timePeriod: TimePeriod! = THREE_MONTHS): CommanderCardWinrateStats @semanticNonNull
  cards: [Card!] @semanticNonNull
  colorId: String @semanticNonNull
  entries(after: String, filters: EntriesFilter, first: Int! = 20, sortBy: EntriesSortBy! = TOP): EntryConnection @semanticNonNull
  id: ID!
  name: String @semanticNonNull
  promo: FirstPartyPromo
  staples: [Card!] @semanticNonNull
  stats(filters: CommanderStatsFilters!): CommanderCalculatedStats @semanticNonNull
}

type CommanderCalculatedStats {
  conversionRate: Float @semanticNonNull
  count: Int @semanticNonNull
  metaShare: Float @semanticNonNull
  topCuts: Int @semanticNonNull
}

type CommanderCardStats {
  conversionRate: Float @semanticNonNull
  topCuts: Int @semanticNonNull
  totalEntries: Int @semanticNonNull
}

type CommanderCardWinrateStats {
  withCard: CommanderCardStats @semanticNonNull
  withoutCard: CommanderCardStats @semanticNonNull
}

type CommanderConnection {
  edges: [CommanderEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
}

type CommanderEdge {
  cursor: String @semanticNonNull
  node: Commander @semanticNonNull
}

type Entry implements Node {
  commander: Commander @semanticNonNull
  decklist: String
  draws: Int @semanticNonNull
  id: ID!
  losses: Int @semanticNonNull
  lossesBracket: Int @semanticNonNull
  lossesSwiss: Int @semanticNonNull
  maindeck: [Card!] @semanticNonNull
  player: Player @semanticNonNull
  standing: Int @semanticNonNull
  tournament: Tournament @semanticNonNull
  winRate: Float
  wins: Int @semanticNonNull
  winsBracket: Int @semanticNonNull
  winsSwiss: Int @semanticNonNull
}

type EntryConnection {
  edges: [EntryEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
}

type EntryEdge {
  cursor: String @semanticNonNull
  node: Entry @semanticNonNull
}

type FirstPartyPromo {
  backgroundImageUrl: String @semanticNonNull
  buttonText: String @semanticNonNull
  description: [String!] @semanticNonNull
  href: String @semanticNonNull
  imageUrl: String
  title: String @semanticNonNull
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean @semanticNonNull
  hasPreviousPage: Boolean @semanticNonNull
  startCursor: String
}

type Player implements Node {
  conversionRate: Float @semanticNonNull
  draws: Int @semanticNonNull
  entries: [Entry!] @semanticNonNull
  id: ID!
  isKnownCheater: Boolean @semanticNonNull
  losses: Int @semanticNonNull
  name: String @semanticNonNull
  topCuts: Int @semanticNonNull
  topdeckProfile: String
  winRate: Float @semanticNonNull
  wins: Int @semanticNonNull
}

type Query {
  card(name: String!): Card @semanticNonNull
  cheaters: [Player!] @semanticNonNull
  commander(name: String!): Commander @semanticNonNull
  commanders(after: String, colorId: String, first: Int! = 20, minEntries: Int, minTournamentSize: Int, sortBy: CommandersSortBy! = CONVERSION, timePeriod: TimePeriod! = ONE_MONTH): CommanderConnection @semanticNonNull
  homePagePromo: FirstPartyPromo
  node(id: ID!): Node
  player(profile: String!): Player @semanticNonNull
  searchResults(types: [SearchResultType!]!): [SearchResult!] @semanticNonNull
  staples(colorId: String, type: String): [Card!] @semanticNonNull
  tournament(TID: String!): Tournament @semanticNonNull
  tournaments(after: String, filters: TournamentFilters, first: Int! = 20, sortBy: TournamentSortBy! = DATE): TournamentConnection @semanticNonNull
}

type SearchResult {
  name: String @semanticNonNull
  url: String @semanticNonNull
}

type Tournament implements Node {
  TID: String @semanticNonNull
  bracketUrl: String @semanticNonNull
  breakdown: [TournamentBreakdownGroup!] @semanticNonNull
  entries(commander: String, maxStanding: Int): [Entry!] @semanticNonNull
  id: ID!
  name: String @semanticNonNull
  promo: FirstPartyPromo
  size: Int @semanticNonNull
  swissRounds: Int @semanticNonNull
  topCut: Int @semanticNonNull
  tournamentDate: String @semanticNonNull
}

type TournamentBreakdownGroup {
  commander: Commander @semanticNonNull
  commanderId: Int @semanticNonNull
  conversionRate: Float @semanticNonNull
  entries: Int @semanticNonNull
  topCuts: Int @semanticNonNull
}

type TournamentConnection {
  edges: [TournamentEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
}

type TournamentEdge {
  cursor: String @semanticNonNull
  node: Tournament @semanticNonNull
}
